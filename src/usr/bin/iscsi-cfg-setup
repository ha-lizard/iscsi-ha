#!/bin/bash
# shellcheck source=/dev/null
##################################################
# HA-Lizard noSAN Installer version 2.2.1
##################################################
#################################################################################################
#
# HA-Lizard - Open Source High Availability Framework for Xen Cloud Platform and XenServer
#
# Copyright 2018 Salvatore Costantino
# ha@pulsesupply.com
#
# This file is part of HA-Lizard.
#
#    HA-Lizard is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    HA-Lizard is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with HA-Lizard.  If not, see <http://www.gnu.org/licenses/>.
#
##################################################################################################
# Load required configuration and functions
source /etc/iscsi-ha/iscsi-ha.load
source /etc/iscsi-ha/iscsi-ha.func
source /usr/libexec/iscsi-ha/common_functions.sh
#######################################
# function remove_local_storage
# Removes the default local SR created
# on a new XenServer installation
#
# Args passed in:
#   None
#
# Returns:
#   0 on success
#   1 on general error
#
# Global variable set in case a
# rollback is required:
#   THIS_HOST_LOCAL_STORAGE_PBD_DEVICE
########################################
remove_local_storage() {
  # Get the local storage SR UUID for the host
  this_host_local_storage=$(xe sr-list type=lvm host="$THIS_HOST" --minimal)
  if [ -z "$this_host_local_storage" ]; then
    echo "Failed to locate SR for local storage"
    return 1
  fi

  # Get the PBD UUID for the local storage SR
  this_host_local_storage_pbd=$(xe pbd-list sr-uuid="$this_host_local_storage" --minimal)
  if [ -z "$this_host_local_storage_pbd" ]; then
    echo "Failed to locate PBD for local storage"
    return 1
  fi

  # Get the device path for the PBD
  THIS_HOST_LOCAL_STORAGE_PBD_DEVICE=$(xe pbd-param-get uuid="$this_host_local_storage_pbd" param-name=device-config param-key=device)

  # Retrieve and canonicalize the device path for the specified PBD.
  # Example: If the PBD points to a symlink like /dev/sdb1,
  # `readlink -e` will resolve it to the canonical path, such as /dev/mapper/vg00-lv00.
  THIS_HOST_LOCAL_STORAGE_PBD_DEVICE=$(readlink -e "$THIS_HOST_LOCAL_STORAGE_PBD_DEVICE")

  # Check if the device path is valid
  if [ -n "$THIS_HOST_LOCAL_STORAGE_PBD_DEVICE" ]; then
    # Write device path to disk
    if [ -d /var/lib/iscsi-ha/state ]; then
      echo "$THIS_HOST_LOCAL_STORAGE_PBD_DEVICE" >/var/lib/iscsi-ha/state/local_storage_device
    else
      echo "$THIS_HOST_LOCAL_STORAGE_PBD_DEVICE" >/tmp/local_storage_device
    fi
  fi

  # Display information for confirmation
  echo "Hostname detected = $THIS_HOST"
  echo "Local Storage SR UUID discovered = $this_host_local_storage"
  echo "Local Storage PBD UUID discovered = $this_host_local_storage_pbd"
  echo
  echo "Press <Enter> to confirm or any other key to cancel."
  read -r confirmation

  # If the user presses Enter (blank input), proceed
  if [ -z "$confirmation" ]; then

    # Unplug PBD
    echo "Unplugging PBD $this_host_local_storage_pbd"
    if ! xe pbd-unplug uuid="$this_host_local_storage_pbd"; then
      echo "Error detected while unplugging PBD $this_host_local_storage_pbd. Exiting"
      return 1
    fi
    sleep 1
    echo

    # Destroy PBD
    echo "Destroying PBD $this_host_local_storage_pbd"
    if ! xe pbd-destroy uuid="$this_host_local_storage_pbd"; then
      echo "Error detected while destroying PBD $this_host_local_storage_pbd. Exiting"
      return 1
    fi
    sleep 1
    echo

    # Remove SR
    echo "Removing Storage $this_host_local_storage"
    if ! xe sr-forget uuid="$this_host_local_storage"; then
      echo "Error detected while removing storage $this_host_local_storage. Exiting"
      exit 1
    fi

    echo "Local storage repository has been successfully removed"
    return 0
  else
    echo "Configuration cancelled. Exiting..."
    exit 1 # Exit if anything other than Enter is pressed
  fi

}
################################################
# function restore_local_storage
# Reinitializes the default XenServer local SR
# in case a rollback is required to bring the
# host's storage back to the default setting
#
# Args passed in:
# None - but function expects to find the
# path to the storage device in
# /tmp/local_storage_device        OR
# /etc/iscsi-ha/state/local_storage_device
#
# Returns:
# 0 on success
# 1 on general error
#
################################################
restore_local_storage() {
  local device

  if [ -f "/etc/iscsi-ha/state/local_storage_device" ]; then
    device="$(</etc/iscsi-ha/state/local_storage_device)"
  elif [ -f "/tmp/local_storage_device" ]; then
    device="$(</tmp/local_storage_device)"
  else
    printf 'Missing device configuration /tmp/local_storage_device' >&2
    return 1
  fi

  if xe sr-create content-type=user device-config:device="$device" \
    host-uuid="$THIS_HOST_UUID" name-label='Local storage' shared=false type=lvm; then
    return 0
  else
    return 1
  fi
}

###########################################
# Function rollback_install
# restores any modified default config
# files and storage repositiries back
# to the state prior to running installer
# Also removes any packages installed
#
# Args passed in:
# Arg1 = installation UUID
#
# Returns:
# 0 on success
# 1 on general error
###########################################
function rollback_install() {

  if [ $1 ]; then
    INSTALL_UID=$1
  else
    echo "Missing required installation UID. Some settings may not be restored"
  fi

  echo "Rolling back installation..."

  rm -f /etc/yum.repos.d/ha-lizard.repo
  service iscsi-ha-watchdog stop
  service iscsi-ha stop
  service ha-lizard stop
  service ha-lizard-watchdog stop
  systemctl stop tgtd
  service drbd stop

  yum --enablerepo=ha-lizard-base,ha-lizard-epel -y remove scsi-target-utils
  rm -rf /etc/tgt
  #yum -y remove sendmail

  yum remove drbd84-utils --enablerepo=ha-lizard-elrepo -y
  yum remove drbd84-utils-sysvinit --enablerepo=ha-lizard-elrepo -y

  rm -f /etc/drdb.conf*

  if [ -d $TMP_LOCATION/$1 ]; then
    FILE_LIST=$(ls $TMP_LOCATION/$INSTALL_UID)
    for file in ${FILE_LIST[@]}; do
      case $file in
      #`basename $LVM_CONF`)
      *lvm*)
        echo "Restoring LVM configuration"
        ###############################
        ## replace dashes with slashes
        ###############################
        REAL_FILE=${file//_/\/}
        mv -f $TMP_LOCATION/$INSTALL_UID/$file $REAL_FILE
        ;;

      $(basename $IPTABLES_CONF))
        echo "Restoring iptables configuration"
        mv -f $TMP_LOCATION/$INSTALL_UID/$(basename $IPTABLES_CONF) $IPTABLES_CONF
        service iptables restart
        ;;
      esac

    done
    restore_local_storage
    rpm -q ha-lizard --quiet
    RETVAL=$?
    if [ $RETVAL -eq 0 ]; then
      rpm -e ha-lizard
      rm -rf /etc/ha-lizard &>/dev/null
    else
      /etc/ha-lizard/scripts/uninstall --auto
    fi

    rpm -q iscsi-ha --quiet
    RETVAL=$?
    if [ $RETVAL -eq 0 ]; then
      rpm -e iscsi-ha
      rm -rf /etc/iscsi-ha &>/dev/null
    else
      /etc/iscsi-ha/scripts/uninstall --auto
    fi
    echo "!!!!! Remember to delete the iSCSI SR from the pool before installing again !!!!!"
    exit $?
  else
    echo "No rollback data found. Some settings may not be restored"
    exit 1
  fi

} # End function rollback_install

make_box "ha-lizard noSAN Automated Installer for XenServer 7
Copyright 2021 Salvatore Costantino
ha@pulsesupply.com

ha-lizard is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

ha-lizard is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along
with ha-lizard. If not, see <http://www.gnu.org/licenses/>.

###########################################################################
################# IMPORTANT - READ BELOW BEFORE PROCEEDING ################
###########################################################################

Check if you have satisfied that the following requirements:
- This installer requires a 2-node XenServer pool. A master and a slave.
- Each host shall have a unique hostname set (localhost is not valid).
- A replication interface and associated IP address should be configured for
  each host before proceeding.
- If you are not converting the default local storage into iSCSI-HA storage,
  then you should know the block device name to be used for storage before
  proceeding (e.g., /dev/sdb).
- If you are converting the default local storage to iSCSI-HA storage, ALL
 data will be lost."

# Ask the user to confirm
echo "Press <Enter> to confirm or any other key to cancel."
read -r confirmation

# If the user presses anything other than Enter, exit
if [ -n "$confirmation" ]; then
  echo "Configuration cancelled. Exiting..."
  exit 1
fi

# Check for required command dependencies
required_commands=(awk grep ip uuidgen basename wget readlink xe tar iptables yum dd echo cat service systemctl hostname curl rpm)

# Iterate over each required command
for cmd in "${required_commands[@]}"; do
  # Check if the command is available
  if ! command -v "$cmd" >/dev/null; then
    # Print message if command is missing and exit with error
    echo "!! Missing Dependency: $cmd"
    exit 1
  else
    # Print message if command is found
    echo "$cmd found OK.."
  fi
done

###################################
# Environment and default values
###################################
FW_CHAIN_NAME='RH-Firewall-1-INPUT'
FW_RULE_POSITION=$(iptables -L ${FW_CHAIN_NAME} --line-numbers | grep 'reject-with' | awk '{print $1}')
REPLICATION_IP_MASTER='10.10.10.1' # Default IP for the master
REPLICATION_IP_SLAVE='10.10.10.2'  # Default IP for the slave
REPLICATION_IP_ISCSI='10.10.10.3'  # Default IP for the iSCSI shared storage
HALIZARD_MIRROR_URL='http://halizard.org/release'
TMP_LOCATION='/tmp/halizard_tmp_'
KERNEL_RELEASE=$(uname -r)
ISCSI_CONFIG_FILE='/etc/tgt/targets.conf'
ISCSI_LUN='10'
LVM_CONF='/etc/lvm/lvm.conf /etc/lvm/master/lvm.conf'
DRBD_CONF_FILE='/etc/drbd.conf'
IPTABLES_CONF='/etc/sysconfig/iptables'
INSTALL_UID=$(uuidgen)
INSTALL_LOG=$TMP_LOCATION/$INSTALL_UID/install.log
THIS_HOST=$(hostname)
THIS_HOST_UUID=$(xe host-list name-label=$THIS_HOST --minimal)

if [ ! -d $TMP_LOCATION ]; then
  mkdir $TMP_LOCATION
fi
mkdir $TMP_LOCATION/$INSTALL_UID
>$INSTALL_LOG

#####################################
# Is this a rollback?
#####################################
if [ "$1" -a -d $TMP_LOCATION/$1 ]; then
  echo "Rolling back configuration"
  rollback_install $1
fi

######################################
# Function to validate the number of hosts in the pool
# Checks if the pool contains exactly 2 hosts and whether the "--force" flag is provided.
#
# Args passed in:
#   $1 - The argument passed to the script (optional; can be "--force")
#
# Returns:
#   0 on success (if validation passes or if "--force" is given)
#   1 on error (if validation fails)
#
# Global variables used:
#   None
######################################
validate_pool_size() {
  # Get the list of hosts in the pool
  local pool_hosts
  pool_hosts=$(xe host-list --minimal)

  # Check if the '--force' flag is provided
  # TODO: looks like the force flag are not documented and only used here. Maybe a better name for it "--single-host"?
  if [ "$1" = "--force" ]; then
    echo "Continuing with forced installation"
    return 0
  fi

  # Validate that there are exactly 2 hosts in the pool
  if [ "$(echo "$pool_hosts" | awk -F, '{print NF}')" -ne 2 ]; then
    echo "Installer requires a pool with exactly 2 hosts. Exiting..."
    return 1
  fi

  # If validation passes
  echo "Pool with 02 hosts validated"
  return 0
}

# Call the function with the first argument (if provided)
validate_pool_size "$1"

#######################################
# Function to check if the host is Master or Slave
# Reads the pool configuration and determines the host's role
#
# Returns:
#   0 if the status is determined successfully (Master or Slave)
#   1 if there is an error (e.g., pool.conf is missing or improperly configured)
#######################################
check_host_role_in_pool() {
  # Define the path to the pool configuration file
  local pool_conf_file="/etc/xensource/pool.conf"

  # Check if the pool configuration file exists
  if [ -e "$pool_conf_file" ]; then
    # Read the pool status (Master or Slave)
    POOL_ROLE=$(cat "$pool_conf_file")

    # Output the host's role in the pool
    echo "This host's role in the pool: $POOL_ROLE"
    return 0
  else
    # If the pool configuration file is missing, show an error message
    echo "$pool_conf_file is missing. Cannot determine if the host is Master or Slave."
    echo "Ensure that the pool is properly configured with exactly two hosts before continuing. Exiting..."
    return 1
  fi
}

# Call the function to check the host's role
check_host_role_in_pool

# Prompt the user for an IP address, validate it, and assign the value to the
# specified variable name.
#
# Parameters:
#   prompt_message - The text to display when prompting the user for an IP address.
#   default_value  - The default value to assign if the user does not enter an IP address.
#   ip_variable_name - The name of the variable to assign the validated IP address to.
#
# Returns:
#   None
get_ip_address() {
  local prompt_message=$1
  local default_value=$2
  local ip_variable_name=$3

  # Local variables
  local success=false
  local ip_override

  # Continue to prompt the user until a valid IP address is entered or the default value is chosen
  while [ $success = false ]; do
    make_box "$prompt_message"
    read -r ip_override
    if [ "$ip_override" ]; then
      # Validate the provided IP
      if is_valid_ipv4 "$ip_override" >/dev/null; then
        # IP is valid
        success=true
        # Assign the validated IP address to the specified variable name
        eval "$ip_variable_name"=\$ip_override
        echo -e "$ip_variable_name set to $ip_override\r\n"
      else
        # IP is invalid
        echo "Invalid IP Address Specified!"
        sleep 1
      fi
    else
      success=true
      # Assign the default value to the specified variable name
      eval "$ip_variable_name"=\$default_value
      echo -e "$ip_variable_name set to $default_value\r\n"
    fi
    sleep 1
  done
}

####################################
# Read master replication IP
####################################
get_ip_address "Enter Replication IP for MASTER host and press <Enter>
(leave blank to select default value of $REPLICATION_IP_MASTER)" $REPLICATION_IP_MASTER REPLICATION_IP_MASTER

####################################
# Read slave replication IP
####################################
get_ip_address "Enter Replication IP for SLAVE host and press <Enter>
(leave blank to select default value of $REPLICATION_IP_SLAVE)" $REPLICATION_IP_SLAVE REPLICATION_IP_SLAVE

# TODO: Add a function to validate if the IP addresses are active on the local and remote hosts.

####################################
# Read floating IP for iSCSI storage
####################################
get_ip_address "Enter Shared/Floating IP for pool storage and press <Enter>
(leave blank to select default value of $REPLICATION_IP_ISCSI)" $REPLICATION_IP_ISCSI REPLICATION_IP_ISCSI

# Function to validate the IP summary configuration
# It prompts the user to confirm the IP values entered
# and exit if the user chooses to cancel
validate_ip_summary() {
  # Display the IP summary and ask the user to confirm
  make_box "Please review the IP configurations:

Master Replication IP: $REPLICATION_IP_MASTER
Slave Replication IP: $REPLICATION_IP_SLAVE
Shared iSCSI IP: $REPLICATION_IP_ISCSI

Are these values correct?"

  # Ask the user to confirm
  echo "Press <Enter> to confirm or any other key to cancel."
  read -r confirmation

  # If the user presses Enter (blank input), proceed
  if [ -z "$confirmation" ]; then
    echo "IPs configuration confirmed. Proceeding with the installation."
    return 0 # Values confirmed
  else
    echo "Configuration cancelled. Exiting..."
    exit 1 # Exit if anything other than Enter is pressed
  fi
}

validate_ip_summary

###################################
# Function to prompt for a hostname
###################################
get_hostname() {
  local prompt="$1" # The message to display to the user
  local hostname="" # Variable to store the entered hostname

  # Display the prompt and read the input
  make_box "$prompt"
  read -r hostname

  # Validate the hostname input
  if [ -z "$hostname" ]; then
    echo "Hostname cannot be empty. Exiting."
    exit 1
  fi

  # Return the validated hostname
  echo "$hostname"
}

###################################
# Get hostname for Master and Slave
###################################
MASTER_HOSTNAME=$(get_hostname "Enter the hostname for the Master and press <Enter>
(!! Must be the configured hostname !!)")

SLAVE_HOSTNAME=$(get_hostname "Enter the hostname for the Slave and press <Enter>
(!! Must be the configured hostname !!)")

#######################################
# Function to determine replication network parameters
# Sets up the REPLICATION_SUBNET and REPLICATION_DEV_NAME
#
# Args passed in:
#   None
#
# Returns:
#   0 on success
#   1 on error (e.g., missing REPLICATION_IP_ISCSI, no suitable interfaces)
#
# Global variables set:
#   REPLICATION_SUBNET        - The subnet derived from REPLICATION_IP_ISCSI
#   REPLICATION_DEV_NAME      - The selected replication network interface
#######################################
determine_replication_params() {
  # Clear the terminal screen for better readability
  clear

  # Ensure REPLICATION_IP_ISCSI is set
  if [ -z "$REPLICATION_IP_ISCSI" ]; then
    echo "Error: REPLICATION_IP_ISCSI is not set. Exiting..."
    exit 1
  fi

  # Calculate the replication subnet using a 24-bit mask
  REPLICATION_SUBNET=$(awk -F. '{print $1"."$2"."$3".0/24"}' <<<"$REPLICATION_IP_ISCSI")
  echo "Replication subnet determined: $REPLICATION_SUBNET"

  # Display all network interfaces with 'xapi' or 'xenbr'
  echo "The following interfaces were found on this host:"
  ip addr show | grep 'inet' | grep -E 'xapi|xenbr'
  echo
  echo "Select replication interface:"

  # Retrieve and store all available interfaces in an array
  mapfile -t IF_LIST < <(ip addr show | grep -E 'xenbr|xapi' | grep : | awk -F ": " '{print $2}')

  # Exit if no suitable interfaces are found
  if [ ${#IF_LIST[@]} -eq 0 ]; then
    echo "No suitable interfaces found. Exiting..."
    exit 1
  fi

  # Display each interface with a numeric option for selection
  for i in "${!IF_LIST[@]}"; do
    echo "Enter $i for interface ${IF_LIST[$i]}"
  done

  # Prompt the user to select an interface
  echo "Enter 0 - $((${#IF_LIST[@]} - 1)) for the desired Replication Interface:"
  read -r SELECT_REPLICATION_DEV_NAME

  # Validate the user's selection and set the replication device name
  if [[ $SELECT_REPLICATION_DEV_NAME =~ ^[0-9]+$ ]] && [ "$SELECT_REPLICATION_DEV_NAME" -ge 0 ] && [ "$SELECT_REPLICATION_DEV_NAME" -lt ${#IF_LIST[@]} ]; then
    REPLICATION_DEV_NAME=${IF_LIST[$SELECT_REPLICATION_DEV_NAME]}
    echo "Interface $REPLICATION_DEV_NAME selected"
  else
    echo "Invalid selection. Exiting..."
    exit 1
  fi
}

# call the function
determine_replication_params

######################################
# Function to update firewall rules
# to permit traffic from the replication subnet
######################################

update_firewall() {
  # Inform the user about the firewall update
  echo "Adding firewall rules to allow traffic between hosts on the replication subnet."

  # Check if the REPLICATION_SUBNET is defined and not empty
  if [ -z "$REPLICATION_SUBNET" ]; then
    echo "Error: REPLICATION_SUBNET is not set."
    return 1
  fi

  # File to back up before saving iptables rules
  IPTABLES_RULES_FILE="/etc/sysconfig/iptables"

  # Backup the iptables rules file before saving
  if [[ -f "$IPTABLES_RULES_FILE" ]]; then
    backup_file "$IPTABLES_RULES_FILE"
  else
    echo "Warning: $IPTABLES_RULES_FILE not found. Skipping backup."
  fi

  # Check if the rule already exists
  # NOTE: iptables commands expect individual arguments for the rule components (e.g., -s, -m comment, --comment),
  # which are not a single string. Wrapping the rule components in a single string ("$RULE") will cause a syntax error.
  if iptables -C INPUT -s "$REPLICATION_SUBNET" -m comment --comment 'ISCSI-CFG Allow traffic from replication subnet' 2>/dev/null; then
    echo "Firewall rule already exists. Skipping."
  else
    # Append the rule to the INPUT table
    iptables -A INPUT -s "$REPLICATION_SUBNET" -m comment --comment 'ISCSI-CFG Allow traffic from replication subnet'
    echo "Firewall rule added successfully."
  fi

  # Save the iptables rules to ensure persistence across reboots
  if ! service iptables save; then
    echo "Error: Failed to save iptables rules."
    return 1
  fi

  # Restart the iptables service to apply the new rules
  if ! service iptables restart; then
    echo "Error: Failed to restart iptables service."
    return 1
  fi

  # Confirm successful update of firewall rules
  echo "Firewall rules have been updated successfully."
}

# Call the function to execute the firewall update
update_firewall

####################################
# Identify the local block device
# to be used for HA-Lizard HA storage
####################################

# Function to prompt for block device input
get_block_device_input() {
  local prompt_message="$1"
  make_box "$prompt_message"
  read -r block_device
  echo "$block_device"
}

# Function to handle the process of selecting a block device
#
# This function prompts the user to select a block device for HA storage.
# If the user chooses to convert local storage to iSCSI-HA storage, it
# calls the remove_local_storage function to perform the conversion and
# retrieves the block device path. If the conversion fails, it prompts the
# user to enter the block device path manually. If the user chooses not to
# convert local storage, it prompts the user to enter the block device path
# manually.
#
# This function modifies the global variable BLOCK_DEVICE by setting it
# to the selected block device path.
#
# Parameters: none
#
# Returns: none
select_block_device() {
  # Prompt for the choice to use local storage
  make_box "Convert local storage to iSCSI-HA storage? <yes or no>"
  read -r USE_LOCAL

  # Handle the user input for local storage selection
  if [ "$USE_LOCAL" = "yes" ]; then
    # Try to convert the local storage to HA storage
    if remove_local_storage; then
      # If the conversion is successful, retrieve the block device path
      BLOCK_DEVICE=$(readlink -f "$THIS_HOST_LOCAL_STORAGE_PBD_DEVICE")
    else
      # Prompt the user to enter the block device path manually
      BLOCK_DEVICE=$(get_block_device_input "
Error converting local SR to usable block device.
Enter full path to backing block device to be used for HA storage
(ex. /dev/sdb)")
    fi

  elif [ "$USE_LOCAL" = "no" ]; then
    # Prompt the user to enter the block device path manually
    BLOCK_DEVICE=$(get_block_device_input "
Enter full path to backing block device to be used for HA storage
(ex. /dev/sdb)")

  else
    # Handle invalid input
    echo "Invalid entry - exiting"
    exit 1
  fi

  # Validate the block device path
  if [ -z "$BLOCK_DEVICE" ] || [ ! -e "$BLOCK_DEVICE" ]; then
    # Handle invalid block device paths
    echo "Error: Invalid block device! Either it is not specified or the path is invalid. Exiting.."
    exit 1
  fi

  # Print the block device path
  echo -e "Backing block device set to $BLOCK_DEVICE\r\n"
}

###################################
# Function to update the LVM filter
#
# This function updates the LVM configuration by inserting a filter to block specific
# devices. LVM should see LV (Logical Volume) only via iSCSI/TGT services.
#
# Parameters:
#   $1: LVM configuration file
#   $2: Block device path
#
# Returns: none
###################################
update_lvm_filter() {
  local lvm_conf="$1"
  local block_device="$2"

  # Define the LVM filter string
  local lv_filter="    filter = [ \"r|$block_device|\", \"r|/dev/drbd[0-9]*|\" ]"

  # Find the line number of 'devices {' in the configuration file
  local lvm_devices_line_begin
  lvm_devices_line_begin=$(grep -n 'devices {' "$lvm_conf" | awk -F: '{print $1}')

  # If the line is found, insert the filter line after it
  if [ -n "$lvm_devices_line_begin" ]; then
    local lvm_insert_row_number
    lvm_insert_row_number=$((lvm_devices_line_begin + 1))
    sed -i "${lvm_insert_row_number}i $lv_filter" "$lvm_conf" || {
      echo "Error: Failed to update $lvm_conf with filter"
      exit 1
    }
  else
    echo "Error: 'devices {' not found in $lvm_conf"
    exit 1
  fi
}

###################################
# Update LVM Filters for all configuration files
###################################
# Iterate over each LVM configuration file
for lvm_conf in "${LVM_CONF[@]}"; do
  # Backup lvm files configuration
  backup_file "$lvm_conf"

  # Update the LVM filter to block certain devices
  update_lvm_filter "$lvm_conf" "$BLOCK_DEVICE"
done

###################################
# Configure iSCSI-HA module
###################################
ISCSI_HA_CONF="DRBD_RESOURCES=iscsi1
ISCSI_TARGET_SERVICE=tgtd
DRBD_VIRTUAL_IP=$REPLICATION_IP_ISCSI
DRBD_VIRTUAL_MASK=255.255.255.0
DRBD_INTERFACE=$REPLICATION_DEV_NAME
MONITOR_MAX_STARTS=5
MONITOR_DELAY=10
MONITOR_KILLALL=1
MONITOR_SCANRATE=5
ENABLE_LOGGING=1
MAIL_USE_SHARED_PARAMS=0
MAIL_ON=1
MAIL_SUBJECT='HA-Lizard noSAN SYSTEM ALERT - FROM HOST: $HOSTNAME'
MAIL_FROM=root@localhost
MAIL_TO=root@localhost
MAIL_SCREEN_TIME=30
SMTP_SERVER=127.0.0.1
SMTP_PORT=25
SMTP_USER=""
SMTP_PASS=""
#END CONFIG FILE"

echo "$ISCSI_HA_CONF" >/etc/iscsi-ha/iscsi-ha.conf

##################################
# Configure HA-Lizard module
##################################
SUCCESS=false
while [ $SUCCESS = false ]; do
  make_box "Enter heuristic IP address used by HA-Lizard.
This can be any IP address reachable by this host
by traversing the XenServer management network and press <Enter>"
  read HEURISTIC_IP
  is_valid_ipv4 $HEURISTIC_IP >/dev/null
  if [ $? -ne 0 ]; then
    echo "Invalid IP Address Specified !"
  else
    SUCCESS=true
    echo -e "Heuristic IP set to $HEURISTIC_IP\r\n"
  fi
done

echo "Press <enter> to continue installation"
read CONTINUE

ha-cfg set-quiet FENCE_ENABLED 1
ha-cfg set-quiet FENCE_HEURISTICS_IPS $HEURISTIC_IP
ha-cfg set-quiet FENCE_MIN_HOSTS 2
ha-cfg set-quiet FENCE_QUORUM_REQUIRED 1
ha-cfg set-quiet FENCE_USE_IP_HEURISTICS 1
ha-cfg set-quiet MONITOR_DELAY 15
ha-cfg set-quiet MONITOR_MAX_STARTS 20
ha-cfg set-quiet XAPI_COUNT 2
ha-cfg set-quiet XAPI_DELAY 10

#####################################
# This code configures DRBD (Distributed Replicated Block Device) sync speeds
# by gathering and evaluating disk throughput and replication link performance
# metrics. It helps determine the optimal sync speeds for initial synchronization
# and resync operations.
#
# The script allows users to select the desired replication link speed from predefined
# options (ranging from 100Mbps to 40Gbps) and disk throughput values. These selections
# are used to calculate the appropriate DRBD sync rates for both maximum and minimum
# transfer speeds (c-max-rate and c-min-rate), ensuring efficient data replication.
#
# This configuration is specifically designed for setting up DRBD replication
# synchronization parameters and is not intended for ongoing replication performance
# adjustments, which depend on the hardware's capabilities.
#####################################

# Default scaling factor for c-min-rate
C_MIN_RATE_SCALE_FACTOR=3

# Prompt the user to select the replication link speed.
#
# This function displays a list of predefined replication link speeds
# (ranging from 100Mbps to 40Gbps) and asks the user to select a speed
# by entering the corresponding number. The selected speed is stored in
# the variable $link_speed and its byte equivalent is stored in
# $LINK_SPEED_BYTES.
drbd_select_link_speed() {
  # Replication link speed options in bps
  declare -a link_speed_list=(
    100000000   # 100Mbps
    1000000000  # 1Gbps
    2000000000  # 2Gbps
    2500000000  # 2.5Gbps
    5000000000  # 5Gbps
    10000000000 # 10Gbps
    20000000000 # 20Gbps
    40000000000 # 40Gbps
  )

  clear
  while :; do
    echo "Select replication link speed"
    for i in "${!link_speed_list[@]}"; do
      echo "[$((i + 1))]  $((link_speed_list[i] / 1000000))Mbps"
    done
    read -r -p "Enter choice (1-${#link_speed_list[@]}): " link_speed_index
    if [[ "$link_speed_index" -ge 1 && "$link_speed_index" -le ${#link_speed_list[@]} ]]; then
      link_speed=${link_speed_list[$((link_speed_index - 1))]}
      LINK_SPEED_BYTES=$((link_speed / 8))
      break
    else
      echo "Invalid selection [$link_speed_index]. Please choose between 1 and ${#link_speed_list[@]}."
    fi
  done
}

# Prompt the user to select the disk throughput speed.
#
# This function displays a list of predefined disk throughput options
# (ranging from 100MiB/s to 1000MiB/s or greater) and asks the user to select a
# speed by entering the corresponding number. The selected speed is stored in
# the variable $DISK_SPEED.
drbd_select_disk_throughput() {
  declare -a disk_speed_list=(
    100000000  # 100MiB/s
    150000000  # 150MiB/s
    200000000  # 200MiB/s
    250000000  # 250MiB/s
    300000000  # 300MiB/s
    400000000  # 400MiB/s
    500000000  # 500MiB/s
    600000000  # 600MiB/s
    700000000  # 700MiB/s
    800000000  # 800MiB/s
    900000000  # 900MiB/s
    1000000000 # 1000MiB/s or greater
  )

  clear
  while :; do
    echo "Select disk throughput speed"
    for i in "${!disk_speed_list[@]}"; do
      echo "[$((i + 1))]  $((disk_speed_list[i] / 1000000))MiB/s"
    done
    read -r -p "Enter choice (1-${#disk_speed_list[@]}): " disk_speed_index
    if [[ "$disk_speed_index" -ge 1 && "$disk_speed_index" -le ${#disk_speed_list[@]} ]]; then
      DISK_SPEED=${disk_speed_list[$((disk_speed_index - 1))]}
      break
    else
      echo "Invalid selection [$disk_speed_index]. Please choose between 1 and ${#disk_speed_list[@]}."
    fi
  done
}

# Calculate DRBD sync rates using user input for link speed and disk throughput.
# The function will determine the maximum sync rate (c-max-rate) based on the
# limiting factor and then calculate the minimum sync rate (c-min-rate) as a
# fraction of c-max-rate, using a default or user-specified scaling factor.
# The function will ensure that the calculated c-max-rate is reasonable and
# that the calculated c-min-rate is not too low.
drbd_calculate_rates() {
  clear

  # Validate inputs
  if [[ -z $LINK_SPEED_BYTES || -z $DISK_SPEED ]]; then
    echo "Error: Link speed and disk throughput must be selected before calculating rates."
    exit 1
  fi

  # Determine c-max-rate based on the limiting factor
  if [[ $DISK_SPEED -gt $LINK_SPEED_BYTES ]]; then
    echo "Link speed [${LINK_SPEED_BYTES}Bps] is less than disk throughput [${DISK_SPEED}Bps]"
    C_MAX_RATE=$((LINK_SPEED_BYTES / 1000000)) # Convert to MiB/s
  else
    echo "Disk throughput [${DISK_SPEED}Bps] is less than link speed [${LINK_SPEED_BYTES}Bps]"
    C_MAX_RATE=$((DISK_SPEED / 1000000)) # Convert to MiB/s
  fi

  # Allow user to modify c-min-rate scaling factor
  read -r -p "Enter scaling factor for c-min-rate (default: ${C_MIN_RATE_SCALE_FACTOR}): " input_scale_factor
  if [[ "$input_scale_factor" =~ ^[1-9][0-9]*$ ]]; then
    C_MIN_RATE_SCALE_FACTOR=$input_scale_factor
  fi

  # Ensure c-max-rate is reasonable
  if [[ $C_MAX_RATE -lt 1 ]]; then
    echo "Error: Calculated c-max-rate is too low [$C_MAX_RATE MiB/s]. Check input values."
    exit 1
  fi

  echo "c-max-rate has been set to [${C_MAX_RATE}MiB/s]"

  # Calculate c-min-rate dynamically based on the scaling factor
  C_MIN_RATE=$((C_MAX_RATE / C_MIN_RATE_SCALE_FACTOR))
  echo "c-min-rate has been set to [${C_MIN_RATE}MiB/s]"
}

# Generates the DRBD configuration file
#
# This function creates a DRBD configuration file using predefined
# and calculated parameters for disk and network settings. It includes
# settings for minimum and maximum sync rates, network buffers, and
# split-brain handlers. A random secure password is generated for use
# as a shared secret in the configuration. The resulting configuration
# file is saved to the path specified by $DRBD_CONF_FILE.
#
# Prerequisites:
# - Variables C_MIN_RATE, C_MAX_RATE, MASTER_HOSTNAME, SLAVE_HOSTNAME,
#   BLOCK_DEVICE, REPLICATION_IP_MASTER, REPLICATION_IP_SLAVE, and
#   DRBD_CONF_FILE must be set prior to calling this function.
#
# Outputs:
# - Writes the DRBD configuration file to $DRBD_CONF_FILE.
drbd_generate_conf() {
  local -r random_password=$(tr -dc 'A-Za-z0-9!?%=' </dev/urandom | head -c 24)

  # Backup the existing DRBD configuration file
  backup_file "$DRBD_CONF_FILE"

  cat <<EOF >"$DRBD_CONF_FILE"
global {
    usage-count no;
}

common {
    disk {
        c-min-rate ${C_MIN_RATE}M;
        c-max-rate ${C_MAX_RATE}M;
        c-fill-target 1M;
    }

    net {
        max-buffers 60000;
        after-sb-0pri discard-zero-changes;
        after-sb-1pri consensus;
        cram-hmac-alg sha1;
        shared-secret $random_password;
    }

    handlers {
        split-brain "/etc/iscsi-ha/scripts/drbd-split-brain-alert";
    }
}

resource iscsi1 {
    protocol C;

    on ${MASTER_HOSTNAME} {
        device /dev/drbd1;
        disk ${BLOCK_DEVICE};
        address ${REPLICATION_IP_MASTER}:7789;
        meta-disk internal;
    }

    on ${SLAVE_HOSTNAME} {
        device /dev/drbd1;
        disk ${BLOCK_DEVICE};
        address ${REPLICATION_IP_SLAVE}:7789;
        meta-disk internal;
    }
}
EOF
  echo "DRBD configuration file has been generated at $DRBD_CONF_FILE"
}

######################################
# Initialize DRBD Configuration and Start Replication
# This function prepares the DRBD setup by performing:
# - ARP updates for the replication network
# - DRBD metadata creation
# - Service startup
# - Synchronization setup for master/slave hosts
#
# Prerequisites:
# - Variables REPLICATION_DEV_NAME, BLOCK_DEVICE, POOL_ROLE, and
#   SLAVE_HOSTNAME must be set prior to calling this function.
#
# Outputs:
# - Writes an ARP update to the replication network interface
# - Creates DRBD metadata for the specified resource
# - Starts the DRBD service
# - Performs synchronization if the current state is "master"
######################################
drbd_initialize() {
  # Send ARP updates for the replication network interface
  echo "Sending ARP update on replication interface"
  if ! send_network_bridge_arp "$REPLICATION_DEV_NAME"; then
    echo "Error: Failed to send ARP update on $REPLICATION_DEV_NAME" >&2
    return 1
  fi

  # Display a message indicating DRBD initialization
  make_box "Initializing DRBD...
This host will wait until its peer connects.
Installation will resume after the DRBD peers connect"

  # Zero out the DRBD block device to ensure a clean state
  echo "Zeroing out DRBD block device"
  if ! dd if=/dev/zero bs=1M count=1 of="$BLOCK_DEVICE" status=none; then
    echo "Error: Failed to write to $BLOCK_DEVICE" >&2
    return 1
  fi

  # Create DRBD metadata for the specified resource
  echo "Creating DRBD metadata for iscsi1"
  if ! drbdadm create-md iscsi1; then
    echo "Error: Failed to create DRBD metadata for iscsi1" >&2
    return 1
  fi

  # Start the DRBD service
  echo "Starting DRBD service"
  if ! service drbd start; then
    echo "Error: Failed to start DRBD service" >&2
    return 1
  fi

  # Additional DRBD syncer configuration for kernels older than 3.x.x
  if [ "$(uname -r | cut -d'.' -f1)" -lt 3 ]; then
    echo "Running drbdadm syncer for iscsi1"
    if ! drbdadm syncer iscsi1; then
      echo "Error: Failed to run drbdadm syncer for iscsi1" >&2
      return 1
    fi
  fi

  # Perform synchronization if the current state is "master"
  # TODO: this will take a while to complete. maybe put it on background or
  # show the users the status of the sync ?
  if [ "$POOL_ROLE" = "master" ]; then
    echo "Synchronizing storage with peer/slave host"
    if ! drbdadm -- --overwrite-data-of-peer primary iscsi1; then
      echo "Error: Failed to synchronize storage as primary" >&2
      return 1
    fi
  fi

  echo "DRBD initialization completed successfully"
}

# TODO: Maybe use a function to format the speeds using thousand separators ?
# example: echo "$speed" | sed ':a;s/\B[0-9]\{3\}\>/.&/;ta'
drbd_select_link_speed
drbd_select_disk_throughput
drbd_calculate_rates
drbd_generate_conf
drbd_initialize

#####################################
# Start Services
#####################################
/usr/libexec/ha-lizard/initialize_cluster_services

make_box "The final step involves creating a iSCSI storage repository in XenCenter,
targeting $REPLICATION_IP_ISCSI.
This completes the noSAN installation process."
